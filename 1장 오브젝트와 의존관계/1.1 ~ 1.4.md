# 1장 오브젝트와 의존관계

스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 객체지향 프로그래밍이 가능한 언어라는 점이다.
자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고,
그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 핵심 철학이다.  

그래서 스프링이 가장 관심을많이 두는 대상은 오브젝트다. 스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다.

### 1.1 초난감 DAO

DAO : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

1.1.2에서 만든 UserDao 라는 클래스에는 여러 가지 문제가 있다. 이 초난감 DAO 코드를 객체지향기술의 원리에 충실한 코드로 개선할 것이다.

UserDao 클래스 코드의 문제점은 무엇인지 생각해보자.
1. 정상적으로 동작하는 이 코드에 문제가 많다고 하는 것일까?
2. 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
3. 그렇게 DAO 코드를 개선했을 떄의 장점은 무엇일까?
4. 그런 장점들이, 또는 미래에 주는 유익은 무엇인가?
5. 또, 객체지향 설계의 원칙과는 무슨 상관이 있을까?
6. 이 DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?

스프링을 공부한다는 것은 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.
스프링은 이러한 질문에 대한 답변을 주지 않는다. 이 답변은 개발자 스스로 만들어 내는 것이지 스프링이 덥석 줄 수 있는게 아니기 때문이다.

### 1.2 DAO의 분리

#### 관심사의 분리
변화는 언제든지 일어날 수 있다. 객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은,
번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.
객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 
하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 더 의미가 있다.

미래를 준비하는데 가장 좋은 방법은 변화의 폭을 최소한으로 줄여주는 것이다.
변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 하는 것이다.
그렇다면 어떻게 위와 같이 문제를 일으키지 않게 할 수 있을까 ?
그것은 **분리와 확장**을 고려한 설계가 있었기 때문이다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

프로그래밍의 기초 개념 중에 **관심사의 분리**라는 게 있다. 
이를 객체지향에 적용해보면, 위와같이 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있다.

1. 중복 코드의 메소드 추출
```
private Connection getConnection() throws ClassNotFoundException,
        SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring",
            "book");
    return c;
}
```
위와 같이 중복된 코드를 getConnection()이라는 이름으로 분리하였다. 
이 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경한다. 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 됐다.
이런 작업을 **리팩토링** 이라고 한다.
또한 위에서 getConnection()이라고 하는 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출**기법이라고 한다.

2. 상속을 통한 확장

getConnect()를 추상메서드로 만들어 다른 슈퍼클래스와 서브클래스로 **분리**한다.
이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.
또한, 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**이라고 한다.

### 1.3 DAO의 확장

3. 클래스 분리
   
상속으로 분리를 한다면 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없는 것도 큰 단점이다.
만약 UserDao 외의 DAO 클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복되는 현상이 나타날 것이다.
따라서 완전히 독립적인 클래스로 만들어 분리시키자.

4. 인터페이스 도입

클래스를 분리하면 특정 클래스와 그 코드에 종속적이기 때문에 자유롭게 확장하기가 힘들다.
가장 좋은 해결책은 두 클래스 사이에 느슨한 연결고리(인터페이스)를 만들어 주는 것이다.
자신을 구현한 클래스에 대해 구체적인 정보를 모두 감춰버리기 떄문에 인터페이스로 추상화해놓은 최소한의 통로를 통해
접근하는 쪽에서는 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 된다. 따라서 클래스를 바꿔도 신경 쓸 일이 없다.

인터페이스를 이용해 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 
결국 어떤 클래스의 오브젝트를 사용할 것인지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다는 문제가 있다.

5. 관계설정 책임의 분리

위와 같은 문제가 발생하는 이유는 UserDao 안에 분리되지 않은, 또 다른 관심사항이 존재하기 때문이다.
이 문제에 대한 해결책은 오브젝트와 오브젝트 사이의 관계를 설정해주어야 한다.

#### 원칙과 패턴
#### 개방 폐쇄 원칙 - OCP (Open-Closed Principle)

OCP란 '클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.'라고 할 수 있다.
우리가 지금까지 리팩토링한 UserDao 클래스는 이제 기능을 확장하는데는 열려있고 변경에는 닫혀 있다고 말할 수 있다.

#### 높은 응집도와 낮은 결합도

개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어개발의 고전적인 원리로도 설명이 가능하다.
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.

높은 응집도란 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수 있다.
낮은 결합도란 느슨하게 연결된 형태를 유지하는 것을 말한다.

#### 전략 패턴

자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 
이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

### 1.4 제어의 역전 (IoC)
제어의 역전(IoC)이라는 것은 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.
즉, 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 말한다. 

#### 팩토리

객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 것을 **팩토리**라고 부른다.
팩토리는 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하려는 것이다.

#### 제어권의 이전을 통한 제어관계 역전

모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.
모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다 

제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.
당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다.
모든 제어 권한을 다른 대상에게 위임하기 때문이다.
프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

IoC를 적용함으로서 생기는 장점
1. 설계가 깔끔해진다.
1. 유연성이 증가한다.
1. 확장성이 증가한다.

스프링은 IoC를 모든 기능의 기초가 되는 기반으로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크다.

