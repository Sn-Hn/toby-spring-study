OCP - 개방 폐쇄 원칙

변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어준다.

템플릿은 이런 OCP를 구현하기 위해 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로 부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 3.1 다시보는 초난감 DAO

**예외상황에 대한 처리**

```java
public void deleteAll() throws SQLException {
	Connection c = dataSource.getConnection();
	
	PreparedStatement ps = c.prepareStatement("delete from users");
	ps.executeUpdate();

	ps.close();
	c.close();
}
```

일반적으로 **서버는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리**한다.

그런데 중간에 예외가 발생해서 메소드를 빠져가나게 되면 close()를 호출하지 못해서 커넥션이 반납되지 못하고 쌓이게 되고 결국 커넥션 풀 리소스가 모자라게 되어 서버가 종료될 수 있다.

위와 같은 경우는 어떤 상황에서도 리소스를 반납할 수 있도록 try-catch-finally를 사용하도록 변경할 수 있다. 이렇게하면 오류가 발생하더라도 finally에서 close()를 호출할 수 있게된다.

단, fianlly에서 close()를 호출할 때 아무 커넥션을 골라서 하면 안된다. close()를 호출할 커넥션이 오류로 인해 null이 들어있을 수 있기때문이다. 따라서 null 체크를 먼저 하고 close()를 해줘야한다. 또한 close() 에서도 오류가 발생할 수 있으므로 close()도 try/catch로 감싸줘야한다.

> 리팩토링 후

```java
public int getCount() throws SQLException {
		Connection c = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		try {
			c = dataSource.getConnection();
			ps = c.prepareStatement("select count(*) from users");
			rs = ps.executeQuery();
			rs.next();

			return rs.getInt(1);
		} catch (SQLException e) {
			throw e;
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
				}
			}

			if (ps != null) {
				try {
					ps.close();
				} catch (SQLException e) {
				}
			}

			if (c != null) {
				try {
					c.close();
				} catch (SQLException e) {
				}
			}
		}
	}
```

## 3.2 변하는 것과 변하지 않는 것

**JDBC tyr-catcth-finally의 문제점**

위의 코드는 try,catch,finally가 이중으로 중첩도 되어있고 메소드도 반복적으로 나오고 있다. 매번 치기는 힘드니 복붙을 하게 된다. 하지만 그러다가 실수로 빼먹거나 코드를 수정하다가 close()를 빼먹을 수도 있다.

이는 결국 DB 커넥션 관리에 영향을 주고 서버의 안정성도 해칠수 있게된다.

**분리와 재사용을 위한 디자인 패턴적용**

→ 변하는 성격이 다른 것을 찾아내자.

로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리한다. 그렇게 변하지 않는 부분을 재사용한다.

**메소드 추출**

```java
public void deleteAll() throws SQLException {
		...
		try {
			c = dataSource.getConnection();

			ps = makeStatement(c);

		} catch (SQLException e)
		...
	}

	private PreparedStatement makeStatement(Connection c) throws SQLException {
		PreparedStatement ps = c.prepareStatement("delete from users");
		ps.executeUpdate();
		return ps;
	}
```

현재 방법은 재사용이 필요한 부분을 두고 변화가 필요한 곳을 추출해주고 있다. 결국 분리된 메소드는 필요한 로직마다 새로 만들어줘야 하므로 OCP가 제대로 적용되지 않은 상태이다.

**템플릿 메소드 패턴의 적용**

- 상속을 통해 기능을 확장해서 사용하는 것
- 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상메서드로 정의해서 쓰는 방법

```java
public class UserDaoDeleteAll extends UserDao {
	protected PreparedStatement makeStatement(Connection c) throws SQLException {
		PreparedStatement ps = c.prepareStatement("delete from users");
		ps.executeUpdate();
		return ps;
	}
}
```

UserDao 클래스를 추상클래스로 만들고 기능의 확장이 필요한 부분은 오버라이드하여 구현하도록 한다.

이 방법의 단점은 DAO로직마다 상속을 통해 새로운 클래스를 만들어야 한다는점이다. 만약 UserDao의 JDBC 메소드가 4개일 경우 4개의 서브 클래스를 만들어서 사용해야된다.
![Untitled](https://user-images.githubusercontent.com/42247724/130057761-f3bc873e-0a01-4cd3-a341-1876df58e55a.png)

또한, 확장 구조가 클래스를 설계하는 시점에 고정되므로 변하지 않는 코드를 가진 userDao의 JDBC try-catch-finally 블록과 PreparedStatement를 담고있는 서브 클래스들이 이미 컴파일 시점에 클래스의 관계가 결정되어 있다. 따라서 관계에 대한 유연성이 떨어진다.

**전략 패턴의 적용**

- OCP 구조를 잘지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 방법.
- 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 **인터페이스를 통해서만 의존**하도록 하는 만든다.
<img width="338" alt="스크린샷_2021-08-19_오후_4 39 20" src="https://user-images.githubusercontent.com/42247724/130057727-64dadaa1-b847-4cde-8fa3-ed11288bfb4d.png">

좌측의 Context의 contextMethod()에서 일정한 구조를 가지고 동작하다가 특정 확장 기능은 Strategy 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 구조

deleteAll()메소드에서 변하지 않는 부분이 contextMethod()가 된다. 이 메소드는 JDBC를 이용해 DB를 업데이트하라는 변하지 않는 맥락(context)를 갖는다.

deleteAll()의 맥락

- DB커넥션 가져오기
- PreparedStatement를 만들어줄 외부 기능 호출하기
- 전달받은 PreparedStatement실행하기
- 예외가 발생할 경우 이를 다시 메소드 밖으로 던지기
- 모든 경우에 만든 PreparedStatement와 Connection을 닫아주기

이 중에서 PreparedStatement를 만들어줄 외부 기능이 전략 패턴에서 말하는 전략이 된다.

**인터페이스**

<img width="395" alt="스크린샷_2021-08-19_오후_4 48 21" src="https://user-images.githubusercontent.com/42247724/130057733-a75ee5d7-8e6a-4695-91ee-7cc11b7212d4.png">

PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어둔 Connection을 전달받아서 PreparedStatement를 만들어서 반환해준다.

**구현체 (전략)**

<img width="395" alt="스크린샷_2021-08-19_오후_4 50 47" src="https://user-images.githubusercontent.com/42247724/130057737-3a7de8c1-9665-4345-b341-654ea2be1999.png">

이렇게 확장된 PreparedStatement 전략인 DeleteAllStatement가 만들어졌다. 이것을 contextMethod()에 해당하는 UserDao의 deleteAll()메소드에서 사용하면 된다.

<img width="395" alt="스크린샷_2021-08-19_오후_4 53 44" src="https://user-images.githubusercontent.com/42247724/130057741-edcb4699-78f5-405f-aa36-8dca36c391b2.png">

그런데 지금 코드에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다. 전략 패턴은 필요에 따라 컨텍스트는 유지하고 전략을 바꿔사용하는 OCP원칙을 따라야하는데 이미 고정이 되어있다는건 좀 이상하다.

**DI 적용을 위한 클라이언트 / 컨텍스트 분리**

Context가 어떤 전략을 사용할지는 Context를 사용하는 앞단의 Client가 결정하는게 일반적이다. Client가 구체적인 전략을 하나 선택하고 객체로 만들어서 Context에 전달하는것이다. Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용하게 된다.

<img width="394" alt="스크린샷_2021-08-19_오후_4 57 33" src="https://user-images.githubusercontent.com/42247724/130057745-bcd20570-faf5-473b-b9f8-81792f15f9fb.png">

위와 같은 구조에서 **전략 오브젝트 생성**과 **컨텍스트의 전달**을 담당하는 책임을 분리시킨 것이 ObjectFactory이고 이를 일반화한 것이 앞에서 본 의존관계 주입 DI이다. 결국 DI란 이런 전략패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.

`StatementStrategy strategy = new DeleteAllStatement();`

컨텍스트에 해당하는 부분은 별도의 메소드로 독립시켜보자. 클라이언트는 `DeleteAllStatement` 오브젝트와 같은 전략 클래스 객체의 메소드를 호출하며 전달해야한다. 이를 위해 전략 인터페이스 `StatementStrategy`를 컨텍스트 메소드 파라미터로 지정할 필요가 있다. 

<img width="394" alt="스크린샷_2021-08-19_오후_5 12 17" src="https://user-images.githubusercontent.com/42247724/130057746-c479c2dc-e077-4833-866f-9bddddc3171e.png">

**컨텍스트 코드**

- 클라이언트로부터 `StatementStrategy`타입의 전략 오브젝트 `stmt`를 제공받고 JDBC try-catch-finally구조로 만들어진 컨텍스트 안에서 작업을 수행한다.
- 제공받은 전략 오브젝트 `stmt`는 `PreparedStatement`생성이 필요한 시점에 호출해서 사용하면 된다.

<img width="394" alt="스크린샷_2021-08-19_오후_5 21 44" src="https://user-images.githubusercontent.com/42247724/130057748-04fd9208-2661-47f4-964d-238941dcb819.png">

**deleteAll()**

- 컨텍스트를 별도의 메소드로 분리했으므로 deleteAll()이 클라이언트가 된다.
- 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임을 지고있다.
- 사용할 전략 클래스 `DeleteAllStatement` 오브젝트를 생성하고, 컨텍스트로 분리한 `jdbcContextWithStatementStrategy("주입할 오브젝트")`메소드를 호출한다.

**결론**

- 전략패턴의 모습을 갖추게 리팩토링했다.
- 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달하는 면에서 DI 구조라고 이해할 수 있다.
- 관심사를 분리하고 유연한 확장관계를 유지하도록 만드는 작업을 했고 이는 매우 중요하다.

## 3.3 JDBC 전략 패턴의 최적화

- deleteAll() 메소드에 담겨있던 변하지 않는 부분 / 변하는 부분을 전략패턴을 이용해서 분리했다.
- `jdbcContextWithStatementStrategy()`는 DAO 메소드들이 공유할 수 있게 됐다.
- DAO 메소드는 전략 패턴의 클라이언트로서 컨텍스트에 해당하는 `jdbcContextWithStatementStrategy("여기로 주입")`메소드에 적절한 전략(바뀌는 로직)을 제공해주는 방법으로 사용할 수 있다.

**전략 클래스의 추가정보**

add() 메소드에도 적용해본다.

<img width="376" alt="스크린샷_2021-08-19_오후_5 33 19" src="https://user-images.githubusercontent.com/42247724/130057751-5ceace1d-7815-45ee-99a0-57c2a96f9e7f.png">

add() 메소드에서 변하는 부분인 `PreparedStatement`를 만드는 코드를 `AddStatement 클래스`로 옮겨 담는다.

그런데 지금 User를 add()해야되는데 유저가 없다. 따라서 유저를 AddStatement 클래스의 생성자를 통해서 제공받게 만들자.

<img width="376" alt="스크린샷_2021-08-19_오후_5 51 05" src="https://user-images.githubusercontent.com/42247724/130057752-34db9b1e-9f69-4547-9a02-b9bf669143dd.png">

클라이언트인 UserDao의 add()메소드에 user정보를 생성자를 통해 전달한다.

<img width="376" alt="스크린샷_2021-08-19_오후_5 55 11" src="https://user-images.githubusercontent.com/42247724/130057753-a4106f4d-85ba-4cdf-bd47-b441522422a2.png">

결과적으로 deleteAll(), add() 모두 preparedStatement를 실행하는 JDBC try - catch - finally 구문을 공`유해서 사용할 수 있게 됐다. 앞으로도 DAO 관련 메소드가 필요할 때마다 `Statement 전략`과 `jdbcContextWithStatementStrategy()` 컨텍스트를 활용할 수 있게 됐다.

**전략과 클라이언트의 동거**

불만사항

1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
    1. 이런식이면 기존 UserDao때보다 클래스 파일의 개수가 많이 늘어난다. 그러면 템플릿 메소드 패턴을 적용한 방법보다 딱히 나은게 없다.
2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있다면, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스를 만들어야 한다.

단계 1) **로컬 클래스**

<img width="376" alt="스크린샷_2021-08-19_오후_6 08 51" src="https://user-images.githubusercontent.com/42247724/130057756-05aa856b-bfe5-4034-b01d-dd8c6eaac4c4.png">
<img width="376" alt="스크린샷_2021-08-19_오후_6 09 04" src="https://user-images.githubusercontent.com/42247724/130057757-28f5fe73-c5cd-4343-83b4-4c23488d3ca0.png">

클래스 파일이 많아지는게 문제라면 StatementStrategy클래스를 독립된 파일로 만들지 않고 UserDao 클래스의 내부 클래스로 정의할 수 있다.

DeleteAllStatement, AddStatement는 UserDao밖에서 사용되지 않고 둘다 UserDao에서만 사용되고, UserDao 메소드 로직에 강하게 결합되어있다. 따라서 내부 클래스로 만들어서 사용할수 있다.

중첩 클래스
- 다른 클래스 내부에 정의되는 클래스를 말한다.
독립적인 오브젝트로 만들어질 수 있는 스태틱 클래스와, 저신이 정의된 클래스의 오브젝트 안에서만 만들어 질 수 있는 내부 클래스로 구분한다.

장점

- 클래스 파일을 줄일 수 있고 add()메소드 내에서 PreparedStatement 생성 로직을 함께 볼 수 있어서 코드 이해에 좋다
- 로컬 클래스는 내부 클래스이므로 자신이 선언된 곳의 정보에 접근할 수 있다. 따라서 굳이 생성자로 User 정보를 넘겨주지 않아도 된다.

<img width="380" alt="스크린샷_2021-08-19_오후_7 46 50" src="https://user-images.githubusercontent.com/42247724/130057758-47366ebd-8714-4609-a7ac-2d065fcfc8a2.png">

단계 2) **익명 내부 클래스**

add()메소드에서만 사용할 용도이므로 이름도 제거한 익명 내부 클래스로 만들 수 있다.

익명 내부 클래스란?

- 이름을 갖지 않는 클래스로 클래스 선언과 오브젝트 생성이 결합 된 형태이다. 상속한 클래스나 구현할 인터페이스를 생성자 대신 사용해서 `new 인터페이스_이름() { 클래스 본문 };`형태로 사용한다. 클래스를 재사용하지 않고 구현할 인터페이스 타입으로만 사용할 경우 유용하다.

AddStatement를 익명 내부클래스로 바꾼다.
<img width="380" alt="스크린샷 2021-08-19 오후 8 07 16" src="https://user-images.githubusercontent.com/42247724/130058531-15c93886-6c87-4350-b0a0-b180b5b552a9.png">
만들어진 익명 내부 클래스를 변수가 아닌 jdbcContextWithStatementStrategy() 메소드의 파라미터에서 바로 생성하게 변경.
```
public void add(final User user) throws SQLException {
		jdbcContextWithStatementStrategy(new StatementStrategy() {
			@Override
			public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
				PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");

				ps.setString(1, user.getId());
				ps.setString(2, user.getName());
				ps.setString(3, user.getPassword());
				return ps;
			}
		});
	}
```

deleteAll() 메소드도 익명 내부 클래스로 처리
```
	public void deleteAll() throws SQLException {
		jdbcContextWithStatementStrategy(new StatementStrategy() {
			@Override
			public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
				return c.prepareStatement("delete from users");
			}
		});
	}
```

## 3.4 컨텍스트와 DI

jdbcContextWithStatementStrategry()를 UserDao클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 변경

** 클래스 분리 **
JdbcContext의 workWithSatementStrategy()메소드에 UserDao내에 있던 컨텍스트 메소드를 옮긴다. 이때 JdbcContext가 DataSource를 주입받을 수 있게 변경한다.
```
public class JdbcContext {
	private DataSource dataSource;

	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
		Connection c = null;
		PreparedStatement ps = null;

		try {
			c = dataSource.getConnection();
			ps = stmt.makePreparedStatement(c);
			ps.executeUpdate();
		} catch (SQLException e) {
			throw e;
		} finally {
			if (ps != null) {
				try {
					ps.close();
				} catch (SQLException e) {
				}
			}

			if (c != null) {
				try {
					c.close();
				} catch (SQLException e) {
				}
			}
		}
	}
}
```

** 빈 의존관계 변경 **

UserDao -> (추가, jdbcContext) -> DataSource
- 의존관계의 중간에 jdbcContext가 추가된다
- 현재 UserDao와 JdbcContext는 인터페이스를 사용하지 않고 DI가 적용되어있다.
- 따라서, 클래스 레벨에서 의존관계가 정해진다.

** 스프링 빈으로 DI **
인터페이스를 사용하지 않고 클래스간에 DI를 하는것이 문제가 있지 않을까?
- 인터페이스를 사이에 두지 않았으므로 온전한 DI는 아니다.
- 객체의 생성과 관계 설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 기법은 적용했다.
- 결국 DI의 기본은 따르고 있는 것

DI구조를 해야하는 이유는?
- 


근데 왜 인터페이스를 두지 않을까?
- 인터페이스가 없다는건 UserDao와 JdbcContext간의 결합도가 매우 높다는 뜻
- UserDao는 항상 JdbcContext와 함께 사용되어야 하는 높은 응집도를 가진다. UserDao가 JPA ORM을 사용한다면 어짜피 JdbcContext도 변경되어야 한다. 이런 구조라면 굳이 인터페이스를 두지 않고 강력한 
관계를 허용하고 DI되게 해도 좋다.








