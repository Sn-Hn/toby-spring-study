# 5장 서비스 추상화

## 5.1 사용자 레벨 관리 기능 추가

### 비즈니스 로직

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 5.1.1 필드 추가

1. **Level 이늄**

User 클래스에 사용자의 레벨을 int 타입으로 넣을 경우 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다는 단점이 있다. 그래서 자바 5 이상에서 제공하는 이늄(Enum)을 이용하는 것이 안전하고 편리하다.

```jsx
public enum Level {
	BASIC(1), SILVER(2), GOLD(3);

	private final int value;

	...
}
```

이렇게 만들어진 이늄은 내부에는 DB에 저장할 int 타입을 가지고 있고, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.

2. **User 필드 추가**

위에서 만든 Level 타입의 변수를 user 클래스에 추가

3. **UserDaoTest 테스트 수정**

UserDaoJdbc와 테스트에도 필드를 추가해야 한다. 테스트 픽스처를 새로 만들고 그에 맞는 생성자를 User 필드에 생성해준다.

4. **UserDaoJdbc 수정**

미리 준비된 테스트가 성공하도록 클래스를 수정한다. 

### 5.1.2 사용자 수정 기능 추가

비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 수정할 정보가 담긴 User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE  문을 이용해 모두 변경해주는 메소드를 만들어보자.

1. **수정 기능 테스트 추가**
2. **UserDao와 UserDaoJdbc 수정**

update 메소드를 추가한다.

3. **수정 테스트 보완**

void로 선언된 update 메소드는 UPDATE 문장에서 WHERE 절이 빠진 경우에 대한 에러를 찾을 수 없다. 이 문제를 해결할 방법은 두 가지가 있다.

- 첫 번째 방법은 update()가 돌려주는 리턴 값을 확인하는 것이다. 영향을 받은 로우의 개수가 1이상이라면 update() 메소드의 SQL에 문제가 있다는 사실을 알 수 있다.
- 두 번째 방법은 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다. 사용자를 두 명 등록해놓고, 한 명만 수정한 뒤 두 명의 정보를 비교해보면 된다.

### 5.1.3 UserService.updateLevels()

DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니기 떄문에 사용자 관리 비즈니스 로직을 담을 클래스를 만들어준다. (UserService)

1. **UserService 클래스와 빈 등록**
2. **UserServiceTest 테스트 클래스**
3. **upgradeLevels() 메소드**
4. **updagradeLevels() 테스트**

### 5.1.4 UserService.add()

### 5.1.5 코드 개선

작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

위의 질문들을 고민해보며 현재까지 작성한 코드들을 리팩토링해보자.

1. upgaradeLevels() 리팩토링
2. user 테스트
3. UserServiceTest 개선

## 5.2 트랜잭션 서비스 추상화

정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그때까지 변겨된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기 상태로 되돌려 놓아야 할까요?

### 5.2.1 모 아니면 도

위와 같은 상황이 왔다면 트랜잭션의 성질 (ACID) 중 Atomicity 원자성을 생각해야 한다. 원자성이란 트랜잭션 단위에서 모든 작업이 반영되거나 모두 반영되지 않아야 한다는 성질이다. 즉, 레벨 관리 작업을 수행하는 도중에 작업을 완료할 수 없다면 모두 작업을 완료할 수 없어야 한다.

**테스트용 UserService 대역**

지금까지 만든 코드를 테스트하기 위해서는 작업 중간에 예외를 강제로 만들어야 한다. 따라서 UserService를 상속해서 테스트에 필요한 기능을 오버라이딩하는 방법을 사용하는 것이 가장 좋다. 하지만 UserService의 메소드 대부분은 private 접근 제한이 걸려 있어서 오버라이딩이 불가능하다. 이 번만 예외로 protected 접근 제어자를 사용한다.

```java
static class TestUserService extends UserService {
	private String id;

	private TestUserService(String id) {
		this.id = id;
	}

	protected void upgradeLevel(User user) {
		if (user.getId().equals(this.id) {
			throw new TestUserserviceException();
			super.upgradeLevel(user);
		}
	}
}

// 테스트용 예외
static class TestUserServiceException extends RuntimeException {
}
```

**강제 예외 발생을 통한 테스트**

우리가 만든 upgradeLevels에 대한 테스트는 역시 실패한다. 네 번째 사용자에서 에러가 발생했는데 두 번째 사용자의 레벨이 업그레이드 됐다. 이 이유가 바로 위에서 설명한 트랜잭션 문제이다.
레벨을 업그레이드하는 작업인 upgradeLevel이 하나의 트랜잭션 안에서 동작하지 않았기 때문이다. 

### 5.2.2 트랜잭션 경계설정

DB는 완벽한 트랜잭션을 지원한다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장한다고 믿을 수 있다. 하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다.

여러 개의 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우 앞에서 처리한 SQL 작업도 취소 시켜야 하는데 이 작업을 **트랜잭션 롤백**이라고 한다.

반대로 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 성공적으로 마무리 됐다면 DB에 알려줘서 확정을 시켜주어야 하는데 이것을 **트랜잭션 커밋**이라고 한다.

**JDBC 트랜잭션의 트랜잭션 경계설정**

모든 트랜잭션은 시작하는 시점과 끝나는 지점이 있다. 시작하는 방법은 한 가지이지만 끝나는 방법은 두 가지로 위에서 설명한 롤백과 커밋이다.

JDBC에서 트랜잭션을 시작하려면 setAutoCommit(false)를 선언해야 한다. 이렇게 트랜잭션의 시작을 선언하고 커밋 또는 롤백으로 트랜잭션을 종료하는 것을 **트랜잭션 경계설정**이라고 한다.

**UserService와 UserDao 트랜잭션 문제**

지금까지 만든 코드에는 트랜잭션 경계설정 코드가 존재하지 않는다. 하나의 템플릿 메소드 안에서 Connection 오브젝트를 가져오고, 작업을 마치면 닫아주고 템플릿 메소드를 빠져 나온다. 결국 템플릿 메소드 호출 한 번에 하나의 DB 커넥션이 만들어지고 닫히는 일까지 일어나는 것이다. 따라서 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.

**비즈니스 로직 내의 트랜잭션 경계설정**

위 문제를 해결하기 위해서는 트랜잭션의 경계설정 작업을 UserService 쪽인 비즈니스 로직 쪽으로 가져와야 한다. 그런데 이 트랜잭션 경계를 비즈니스 로직으로 가져오면 여러가지 문제점이 발생한다.

1. DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다.
2. DAO의 메소드와 비즈니스 로직을 담고 있는 UserService의 메소드에 Connection 파라미터가 추가되어야 한다.
3. Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 UserDao는 더 이상 데이터 엑세스 기술에 독립적일 수가 없다는 점이다.
4. DAO 메소드에 Connection 파라미터를 받게 하면 테스트 코드에도 영향을 미친다.

### 5.2.3 트랜잭션 동기화

위와 같은 문제점들을 해결하기 위해 트랜잭션 동기화를 사용한다. 트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다.

**트랜잭션 동기화를 사용한 경우의 작업 흐름**

1. UserService는 Connection을 생성
2. 이를 트랜잭션 동기화 저장소에 저장해두고 Connection의 setAutoCommit(false)를 호출해 트랜잭션을 시작
3. 첫 번째 update() 메소드가 호출
4. 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 오브젝트가 존재하는지 확인
    - 2. upgradeLevels() 메소드 시작 부분에서 저장해둔 Connection을 가져온다.
5. Connection을 이용해 PreparedStatement를 만들어 수정 SQL을 실행. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는 JdbcTemplate은 Connection은 닫지 않은 채로 작업을 마친다.
6. 두 번째 update()가 호출
7. 트랜잭션 동기화 저장소에서 Connection을 가져옴
8. Connection 사용
9. 반복 ...
10. Connection의 commit()을 호출해서 트랜잭션 완료
11. 트랜잭션 저장소가 더 이상 Connection 오브젝트를 저장해두지 않도록 제거

어느 작업 중에라도 예외 상황이 발생하면 즉시 rollback()을 호출해야 한다.

트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려가 없다.

이렇게 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일이 Connection 오브젝트를 전달할 필요가 없다.

**트랜잭션 동기화 적용**

문제는 멀티스레드 환경에서도 안전한 트랜잭션 동기화 방법을 구현하는 일이 기술적으로 간단하지 않다는 점이다. 다행히 스프링은 JdbcTemplate과 더불이 이런 트랜잭션 동기화 기능을 지원하는 간단한 유틸리티 메소드를 제공하고 있다.

**JdbcTemplate과 트랜잭션 동기화**

JdbcTemplate은 영리하게 동작하도록 설계되어 있다. 만약 미리 생성되서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다. 반면에 upgradeLevels() 메소드처럼 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와 사용한다. 이를 통해 이미 시작된 트랜잭션에 참여하는 것이다. 

따라서 트랜잭션이 굳이 필요 없다면 바로 호출해서 사용하고, DAO 외부에서 트랜잭션을 만들고 이를 관리할 필요가 있다면 미리 DB 커넥션을 생성한 다음 트랜잭션 동기화를 해주고 사용하면 된다.

### 5.2.4 트랜잭션 서비스 추상화

**기술과 환경에 종속되는 트랜잭션 경계설정 코드**

한 개 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는 건 JDBC의 Connection을 이용한 트랜잭션 방식인 로컬 트랜잭션으로는 불가능하다. 로컬 트랜잭션은 하나의 DB Connection에 종속되기 때문이다. 따라서 각 DB와 독립적으로 만들어지는 Connection을 통해서가 아니라, 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 **글로벌 트랜잭션 방식**을 사용해야 한다. 글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다.

자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 JTP (Java Transaction API)를 제공하고 있다.

JTA를 이용해 여러 개의 DB 또는 메시징 서버에 대한 트랜잭션을 관리하는 방법은 JDBC나 JMS API를 사용해서 트랜잭션을 직접 제어하지 않고 JTA를 통해 트랜잭션 매니저가 관리하도록 위임한다. 트랜잭션 매니저는 DB와 메시징 서버를 제어하고 관리하는 각각의 리소스 매니저와 XA 프로토콜을 통해 연결된다. 이를 통해 트랜잭션 매니저가 실제 DB와 메시징 서버의 트랜잭션을 종합적으로 제어할 수 있게 되는 것이다. 이렇게 JTA를 이용해 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는 분산 트랜잭션 또는 글로벌 트랜잭션이 가능해진다

**트랜잭션 API의 의존관계 문제와 해결책**

하이버네이트를 이용한 트랜잭션 관리 코든느 JDBC와 JTA의 코드와는 다르다. 다시 특정 데이터 액세스 기술에 종속되는 구조가 발생했다. 

다행히도 트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는 유사한 구조다. 이렇게 여러 기술의 사용 방법에 공통점이 있다면 추상화를 생각해볼 수 있다. 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다. 그렇다면 앞서 말한 기술들의 트랜잭션 경계설정 방법에서 공통점이 있을 것이다. 이 공통적인 특징을 모아서 추상화된 트랜잭션 관리 계층을 만들 수 있다.

**스프링의 트랜잭션 서비스 추상화**

스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 `PlatformTransactionManager`다. 이 인터페이스를 구현한 클래스 중 각 기술에 맞는 클래스를 사용하면 된다.

## 5.3 서비스 추상화와 단일 책임 원칙

### 수직, 수평 계층구조와 의존 관계

기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다. UserDao와 UserService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고, 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다. 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리했다. 같은 계층에서 수평적인 분리라고 볼 수 있다.

 트랜잭션 추상화는 조금 다르다. 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우 레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.

 애플리케이션 로직의 종류에 따른 수펴적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다. DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는데 있다. 

### 단일 책임 원칙

단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다. 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수도 있다.

### 단일 책임 원칙의 장점

- 어떤 변경이 필요할 때 수정 대상이 명확해진다 .
- 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다.

적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다. 이를 위한 핵심적인 도구가 DI다.

단일 채임 원칙을 잘 지키는 코드를 만드려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오기 떄문이다. 이런 과정에서 다양한 디자인 패턴이 자연스럽게 적용되기도 한다. 객체지향 설계 원칙을 잘 지켜서 만든 코드는 테스트하기도 편하다.

## 5.4 메일 서비스 추상화

### 5.4.3 테스트를 위한 서비스 추상화

JavaMail처럼 테스트하기 힘든 구조인 API를 테스트하기 좋게 만드는 방법이 있다. 트랜잭션을 적용하면서 살펴봤던 서비스 추상화를 적용하면 된다. 

일반적으로 서비스 추상화라고 하면 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있는 접근 방법을 제공해주는 것을 말한다. 반면에 JavaMail의 경우처럼 테스트를 어렵게 만드는 건전하지 않은 방식으로 설계된 API를 사용할 때도 유용하게 쓰일 수 있다. 

서비스 추상화란 이렇게 원활한 테스트만을 위해서도 충분히 가치가 있다. 기술이나 환경이 바뀔 가능성이 있음에도, JavaMail처럼 확장이 불가능하게 설계해 놓은 API를 사용해야 하는 경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다. 특별히 외부의 리소스와 연동하는 대부분 작업은 추상화의 대상이 될 수 있다.

### 5.4.4 테스트 대역

스프링의 XML 설정파일을 테스트용으로 따로 만든 이유는 개발자 환경에서 손쉽게 이용할 수 있는 테스트용 DB를 사용하도록 만들기 위해서다. 이처럼 테스트 환경에서 유용하게 사용하는 기법이 있다. 대부분 테스트할 대상이 의존하고 있는 오브젝트를 DI를 통해 바꿔치기하는 것이다.

**의존 오브젝트의 변경을 통한 테스트 방법**

테스트 대상이 되는 오브젝트가 또 다른 오브젝트에 의존하는 일은 매우 흔하다. UserService는 이미 DI를 통해 주입받은 오브젝트만 세 가지다. 이렇게 하나의 오브젝트가 사용하는 오브젝트를 DI에서 의존 오브젝트라고 불러왔다. 작은 기능이라도 다른 오브젝트의 기능을 사용하면, 사용하는 오브젝트의 기능이 바뀌었을 때 자신이 영향을 받을 수 있기 때문에 의존하고 있다고 말하는 것이다. 의존 오브젝트를 협력 오브젝트라고도 한다.

이렇게 테스트 대상인 오브젝트가 의존 오브젝트를 갖고 있기 떄문에 발생하는 여러 가지 테스트상의 문제점이 있다. 대표적으로 간단한 오브젝트의 코드를 테스트하는데 너무 거창한 작업이 뒤따르는 경우다. 이럴때 스프링 DI는 큰 위력을 발휘한다.

실전에서 사용할 오브젝트를 교체하지 않더라도, 단지 테스트만을 위해서도 DI는 유용하다. 운영 중에는 절대 바뀌지 않더라도 테스트떄는 바꿀 수 밖에 없기 떄문이다. 그래서 인터페이스를 사용하고 어떤 클래스의 오브젝트를 사용할 지 외부에서 주입해주도록 DI를 적용해야 한다.

**테스트 대역의 종류와 특징**

테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 이런 오브젝트를 통틀어서 **테스트 대역**이라고 부른다.

대표적인 테스트 대역은 **테스트 스텁**이다. 테스트 스텁은 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트동안에 코드가 정상적으로 수행할 수 있도록 돕는 것을 말한다. 일반적으로 테스트 스텁은 메소드를 통해 전달하는 파라미터와 달리, 테스트 코드 내부에서 간접적으로 사용된다. 따라서 DI 등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.

많은 경우 테스트 스텁이 결과를 돌려줘야 할 때도 있다. 리턴 값이 있는 메소드를 이용하는 경우에는 결과가 필요한데 이럴 땐 스텁에 미리 테스트 중에 필요한 정보를 리턴해주도록 만들 수 있다. 또는 어떤 스텁은 메소드를 호출하면 강제로 예외를 발생시켜 테스트 대상 오브젝트가 예외 상황에서 어떻게 반응하지를 테스트할 때 적용할 수도 있다.

테스트 대상 오브젝트의 메소드가 돌려주는 결과뿐 아니라 테스트 오브젝트가 간접적으로 의존 오브젝트에 넘기는 값과 그 행위 자체에 대해서도 검증하고 싶다면 테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 특별히 설계된 **목 오브젝트**를 사용해야 한다. 목 오브젝트는 스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서, 테스트 오브젝트와 자신의 사이에서 일어나는 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용할 수 있다. 

**목 오브젝트를 이용한 테스트**

목 오브젝트를 이용한 테스트라는 게, 작성하기는 간단하면서도 기능은 상당히 막강하다는 사실을 알 수 있다. 보통의 테스트 방법으로는 검증하기가 매우 까다로운 테스트 대상 오브젝트의 내부에서 일어나는 일이나 다른 오브젝트 사이에서 주고받는 정보까지 검증하는 일이 손쉽기 떄문이다.

테스트가 수행될 수 있도록 의존 오브젝트에 간접적으로 입력 값을 제공해주는 스텁 오브젝트와 간접적인 출력 값까지 확인이 가능한 목 오브젝트, 이 두 가지는 테스트 대역의 가장 대표적인 방법이며 효과적인 테스트 코드를 작성하는 데 빠질 수 없는 중요한 도구다.
